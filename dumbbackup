#!/usr/bin/env perl
use strict;
use warnings;
use v5.010;

use Getopt::Long;
use File::Spec;
use Text::ParseWords 'shellwords';
use POSIX 'strftime';
use Fcntl qw( :flock );
use Data::Dumper;

my $USAGE =
"Usage: $0 [ --server|target=hostname ] [ --store=dir ] [ --check ] [ --cleanup ] [ --nice=N ] [ --ionice=N ] [ --rsync-opts=OPTS ] [ --exclude=PATTERN ] dir1 dir2 ...";
my %option = (
    store       => '/backup',
    keep_days   => 10,
    keep_months => 6,
    keep_years  => 1,
);

GetOptions(
    \%option,                  'debug',
    'server=s',                'target=s',
    'store=s',                 'cleanup',
    'nice=i',                  'ionice=i',
    'exclude=s@',              'check',
    'keep_years|keep-years=i', 'keep_months|keep-months=i',
    'keep_days|keep-days=i',   'rsync_opts|rsync-opts=s',
) or die $USAGE;

# various parameters
my @cmd;
my @filters = map "--exclude=$_", @{ $option{exclude} };
my $today = strftime "%Y-%m-%d", localtime;
my $dest = "$option{store}/$today";

# acquire the lock
my $lock = File::Spec->catfile( File::Spec->tmpdir, join '-', 'dumbbackup',
      $option{server} ? ( server => $option{server} )
    : $option{target} ? ( target => $option{target} )
    :                   ('local') );
open my $fh, '>', $lock or die "Can't open $lock: $!";
die "Can't acquire lock on $lock: $!" if !flock( $fh, LOCK_EX | LOCK_NB );

# TODO: should --target and --server be mutually exclusive?
my @backups;
if ( $option{server} ) {
    @backups = grep $_ ne $dest, sort split /\n/,
      qx{ssh $option{server} ls -d $option{store}/????-??-??};
    $dest = "$option{server}:$dest";
}
else {
    @backups = grep $_ ne $dest, sort grep -d,
        glob "$option{store}/????-??-??";
    push @filters, "--exclude=$option{store}";
}

# rsync options
my @rsync_opts = qw( -aH --partial --numeric-ids );
push @rsync_opts, shellwords( $option{rsync_opts} ) if $option{rsync_opts};
push @rsync_opts, map "--link-dest=$_", reverse @backups if @backups;

# remaining arguments are a list of directories to backup
my @src;
for (@ARGV) {    # assume Unix-like directories with no trailing slash
    push @src, join ':', $option{target} || (), $_;
    s{/$}{};
    push @filters, "--include=$_/**";
    my @dirs = File::Spec->splitdir($_);
    while (@dirs) {
        pop @dirs;
        my $dir = File::Spec->catdir(@dirs);
        push @filters, "--include=$dir" if $dir;
    }
}
push @filters, '--exclude=*';
@filters = do { my %seen; grep !$seen{$_}++, @filters };

# handle niceness
my @nice = (
  ( nice   => '-n', $option{nice}   )x!! $option{nice},
  ( ionice => '-c', $option{ionice} )x!! $option{ionice}
);
if ( $option{target} && @nice ) {
    push @rsync_opts, "--rsync-path=@nice rsync";
}
else {
    unshift @cmd, @nice;
}

# build the rsync command
push @cmd, rsync => @rsync_opts, @filters, @src, $dest;

if( $option{check} ) {
    print $option{debug} ? Data::Dumper->Dump( [ \@cmd ], [ '*cmd' ] ) : "@cmd\n";
}
else{
   system @cmd;
}

# cleanup
if ( $option{cleanup} ) {
    local $Data::Dumper::Indent = 0;
    my ( %y, %m, %k );
    /\b((\d{4})-\d{2})-\d{2}$/
      and push @{ $m{$1} }, $_
      and push @{ $y{$2} }, $_
      for @backups;
    $k{$_}++ for grep $_, ( reverse @backups )[ 0 .. $option{keep_days} - 1 ];
    $k{ $m{$_}[0] }++
      for grep $_, ( reverse sort keys %m )[ 0 .. $option{keep_months} - 1 ];
    $k{ $y{$_}[0] }++
      for grep $_, ( reverse sort keys %y )[ 0 .. $option{keep_years} - 1 ];
    for my $bye ( grep !$k{$_}, @backups ) {
        my @rm = (
            $option{server} ? ( ssh => $option{server} ) : (), @nice,
            rm => '-rf',
            $bye
        );
        if ( $option{check} ) {
            print $option{debug} ? Data::Dumper->Dump( [ \@rm ], [ '*rm' ] ) : "@rm", "\n";
        }
        else {
            system @rm;
        }
    }
}
